From 94faac40833f067606864994afe404171859fb83 Mon Sep 17 00:00:00 2001
From: Vladimir Azarov <vladimirazmich@gmail.com>
Date: Thu, 2 Oct 2025 22:52:13 +0200
Subject: [PATCH] Task 3

Implement task3 from internship assignment. Compile the module with
"make -C sample/task".

The module sample/task/task.ko does several operations involving
linked lists.

This patch depends on 0001-Task-1.patch

Signed-off-by: Vladimir Azarov <vladimirazmich@gmail.com>
---
 samples/task/Makefile |   4 +-
 samples/task/task.c   | 119 +++++++++++++++++++++++++++++++++++++++---
 2 files changed, 115 insertions(+), 8 deletions(-)

diff --git a/samples/task/Makefile b/samples/task/Makefile
index 2e8f0fa453c2..31ad173f67f2 100644
--- a/samples/task/Makefile
+++ b/samples/task/Makefile
@@ -12,9 +12,9 @@ clean:
 
 else
 
-CONFIG_TASK1 ?= m
+CONFIG_TASK3 ?= m
 
 ccflags-y += -DDEBUG
-obj-$(CONFIG_TASK1) := task.o
+obj-$(CONFIG_TASK3) := task.o
 
 endif
diff --git a/samples/task/task.c b/samples/task/task.c
index 54e5d25cce5f..28f1f80c9534 100644
--- a/samples/task/task.c
+++ b/samples/task/task.c
@@ -3,21 +3,128 @@
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/init.h>
+#include <linux/string.h>
 #include <linux/printk.h>
+#include <linux/slab.h>
 #include <linux/module.h>
 
-static int __init task1_init(void)
+struct identity {
+	char name[20];
+	int id;
+	bool hired;
+	struct list_head node;
+};
+
+static LIST_HEAD(identities);
+
+static int identity_create(char *name, int id)
+{
+	struct identity *tmp;
+	int name_len = strnlen(name, 20);
+
+	if (name_len >= 20)
+		return -ENAMETOOLONG;
+	tmp = kzalloc(sizeof(*tmp), GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+	strscpy(tmp->name, name);
+	tmp->id = id;
+	tmp->hired = false;
+	list_add_tail(&tmp->node, &identities);
+	return 0;
+}
+
+static struct identity *identity_find(int id)
+{
+	struct identity *cur;
+
+	list_for_each_entry(cur, &identities, node) {
+		if (cur->id == id)
+			return cur;
+	}
+	return NULL;
+}
+
+static void identity_destroy(int id)
+{
+	struct identity *tmp = identity_find(id);
+
+	if (!tmp)
+		return;
+	list_del(&tmp->node);
+}
+
+static int identity_hire(int id)
+{
+	struct identity *tmp = identity_find(id);
+
+	if (!tmp)
+		return -ENOENT;
+	tmp->hired = true;
+	return 0;
+}
+
+static int print_create_error_and_error(int ret)
+{
+	WARN_ON(ret != -ENOMEM || ret != -ENAMETOOLONG);
+
+	pr_err("unable to create identity: ");
+	if (ret == -ENOMEM)
+		pr_err("out of memory\n");
+	else
+		pr_err("identity name is too long\n");
+	return ret;
+}
+
+static int __init task3_init(void)
 {
-	pr_debug("Hello, KernelCare!\n");
+	struct identity *temp;
+	int ret;
+
+	pr_debug("Loading\n");
+
+	ret = identity_create("Volodymyr Azarov", 1);
+	if (ret != 0)
+		return print_create_error_and_error(ret);
+
+	ret = identity_create("Tomasz Bukowski", 2);
+	if (ret != 0)
+		return print_create_error_and_error(ret);
+
+	temp = identity_find(1);
+	if (!temp) {
+		pr_err("no identity with id = 1\n");
+		return -ENOENT;
+	}
+	pr_debug("id 1 = %s\n", temp->name);
+
+	if (identity_hire(1) != 0) {
+		pr_err("unable to hire candidate with id = 1\n");
+		return -EINVAL;
+	}
+
+	temp = identity_find(10);
+	if (temp) {
+		pr_err("id 10 found, even though if was not added\n");
+		return -EINVAL;
+	}
+
+	identity_destroy(2);
+	identity_destroy(1);
+
+	if (!list_empty(&identities)) {
+		pr_err("identity list is not empty, even though it should be\n");
+		return -EINVAL;
+	}
 	return 0;
 }
 
-static void __exit task1_exit(void)
+static void __exit task3_exit(void)
 {
 	pr_debug("Unloading\n");
 }
 
-module_init(task1_init);
-module_exit(task1_exit);
+module_init(task3_init);
+module_exit(task3_exit);
 MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Task 1");
+MODULE_DESCRIPTION("Task 3");
-- 
2.44.0

